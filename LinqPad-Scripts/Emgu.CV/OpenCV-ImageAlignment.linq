<Query Kind="Program">
  <Reference>&lt;ProgramFilesX86&gt;\IronSoftware\IronOcr\lib\netstandard2.0\BitMiracle.LibTiff.NET.dll</Reference>
  <Reference>&lt;NuGet&gt;\emgu.cv.runtime.windows\4.9.0.5494\runtimes\win-x64\native\cvextern.dll</Reference>
  <Reference>&lt;NuGet&gt;\emgu.cv\4.9.0.5494\lib\net8.0-ios16.1\Emgu.CV.dll</Reference>
  <Reference>&lt;NuGet&gt;\emgu.cv\4.9.0.5494\lib\net8.0-ios16.1\Emgu.CV.xml</Reference>
  <Reference>&lt;ProgramFilesX86&gt;\IronSoftware\IronOcr\runtimes\win-x64\native\eng.base.traineddata</Reference>
  <Reference>&lt;ProgramFilesX86&gt;\IronSoftware\IronOcr\runtimes\win-x64\native\eng.best.traineddata</Reference>
  <Reference>&lt;ProgramFilesX86&gt;\IronSoftware\IronOcr\runtimes\win-x64\native\eng.fast.traineddata</Reference>
  <Reference>&lt;ProgramFilesX86&gt;\IronSoftware\IronOcr\runtimes\win-x64\native\eng.user-patterns</Reference>
  <Reference>&lt;ProgramFilesX86&gt;\IronSoftware\IronOcr\runtimes\win-x64\native\eng.user-words</Reference>
  <Reference Relative="..\..\bin\Debug\net7.0\IanAutomation.dll">F:\projects_csharp\IanAutomation\bin\Debug\net7.0\IanAutomation.dll</Reference>
  <Reference>&lt;ProgramFilesX86&gt;\IronSoftware\IronOcr\lib\netstandard2.0\IronOcr.dll</Reference>
  <Reference>&lt;ProgramFilesX86&gt;\IronSoftware\IronOcr\runtimes\win-x64\native\IronOcrInterop.dll</Reference>
  <Reference>&lt;ProgramFilesX86&gt;\IronSoftware\IronOcr\runtimes\win-x64\native\IronPdfInterop.dll</Reference>
  <Reference>&lt;ProgramFilesX86&gt;\IronSoftware\IronOcr\lib\netstandard2.0\IronSoftware.Abstractions.dll</Reference>
  <Reference>&lt;ProgramFilesX86&gt;\IronSoftware\IronOcr\lib\netstandard2.0\IronSoftware.Drawing.Common.dll</Reference>
  <Reference>&lt;ProgramFilesX86&gt;\IronSoftware\IronOcr\lib\netstandard2.0\IronSoftware.Logger.dll</Reference>
  <Reference>&lt;ProgramFilesX86&gt;\IronSoftware\IronOcr\lib\netstandard2.0\IronSoftware.Shared.dll</Reference>
  <Reference>&lt;ProgramFilesX86&gt;\IronSoftware\IronOcr\runtimes\win-x64\native\liblept-5.dll</Reference>
  <Reference>&lt;ProgramFilesX86&gt;\IronSoftware\IronOcr\runtimes\win-x64\native\libtesseract-5.dll</Reference>
  <Reference>&lt;NuGet&gt;\emgu.cv.runtime.windows\4.9.0.5494\runtimes\win-x64\native\libusb-1.0.dll</Reference>
  <Reference>&lt;ProgramFilesX86&gt;\IronSoftware\IronOcr\runtimes\win-x64\native\LICENSE</Reference>
  <Reference>&lt;ProgramFilesX64&gt;\LINQPad8\linqpad.config</Reference>
  <Reference>&lt;ProgramFilesX86&gt;\IronSoftware\IronOcr\lib\netstandard2.0\Microsoft.Extensions.Configuration.Abstractions.dll</Reference>
  <Reference>&lt;ProgramFilesX86&gt;\IronSoftware\IronOcr\lib\netstandard2.0\Microsoft.Extensions.Configuration.Binder.dll</Reference>
  <Reference>&lt;ProgramFilesX86&gt;\IronSoftware\IronOcr\lib\netstandard2.0\Microsoft.Extensions.Configuration.dll</Reference>
  <Reference>&lt;ProgramFilesX86&gt;\IronSoftware\IronOcr\lib\netstandard2.0\Microsoft.Extensions.Configuration.FileExtensions.dll</Reference>
  <Reference>&lt;ProgramFilesX86&gt;\IronSoftware\IronOcr\lib\netstandard2.0\Microsoft.Extensions.Configuration.Json.dll</Reference>
  <Reference>&lt;ProgramFilesX86&gt;\IronSoftware\IronOcr\lib\netstandard2.0\Microsoft.Extensions.FileProviders.Abstractions.dll</Reference>
  <Reference>&lt;ProgramFilesX86&gt;\IronSoftware\IronOcr\lib\netstandard2.0\Microsoft.Extensions.FileProviders.Physical.dll</Reference>
  <Reference>&lt;ProgramFilesX86&gt;\IronSoftware\IronOcr\lib\netstandard2.0\Microsoft.Extensions.FileSystemGlobbing.dll</Reference>
  <Reference>&lt;ProgramFilesX86&gt;\IronSoftware\IronOcr\lib\netstandard2.0\Microsoft.Extensions.Logging.Abstractions.dll</Reference>
  <Reference>&lt;ProgramFilesX86&gt;\IronSoftware\IronOcr\lib\netstandard2.0\Microsoft.Extensions.Primitives.dll</Reference>
  <Reference>&lt;NuGet&gt;\emgu.cv.runtime.windows\4.9.0.5494\runtimes\win-x64\native\opencv_videoio_ffmpeg490_64.dll</Reference>
  <Reference>&lt;ProgramFilesX86&gt;\IronSoftware\IronOcr\runtimes\win-x64\native\osd.traineddata</Reference>
  <Reference>&lt;ProgramFilesX86&gt;\IronSoftware\IronOcr\runtimes\win-x64\native\pdf.ttf</Reference>
  <Reference>&lt;ProgramFilesX86&gt;\IronSoftware\IronOcr\runtimes\win-x64\native\pdf.ttx</Reference>
  <Reference>&lt;ProgramFilesX86&gt;\IronSoftware\IronOcr\runtimes\win-x64\native\Pdfium.Native.deployment.json</Reference>
  <Reference>&lt;ProgramFilesX86&gt;\IronSoftware\IronOcr\lib\netstandard2.0\SixLabors.Fonts.dll</Reference>
  <Reference>&lt;ProgramFilesX86&gt;\IronSoftware\IronOcr\lib\netstandard2.0\SixLabors.ImageSharp.dll</Reference>
  <Reference>&lt;ProgramFilesX86&gt;\IronSoftware\IronOcr\lib\netstandard2.0\SixLabors.ImageSharp.Drawing.dll</Reference>
  <Reference>&lt;ProgramFilesX86&gt;\IronSoftware\IronOcr\lib\netstandard2.0\System.Configuration.ConfigurationManager.dll</Reference>
  <Reference>&lt;ProgramFilesX86&gt;\IronSoftware\IronOcr\lib\netstandard2.0\System.Numerics.Vectors.dll</Reference>
  <Reference>&lt;ProgramFilesX86&gt;\IronSoftware\IronOcr\lib\netstandard2.0\System.Runtime.CompilerServices.Unsafe.dll</Reference>
  <Reference>&lt;ProgramFilesX86&gt;\IronSoftware\IronOcr\runtimes\win-x64\native\Tesseract.Windows.deployment.json</Reference>
  <Namespace>Emgu.CV</Namespace>
  <Namespace>Emgu.CV.CvEnum</Namespace>
  <Namespace>Emgu.CV.Features2D</Namespace>
  <Namespace>Emgu.CV.Structure</Namespace>
  <Namespace>Emgu.CV.Util</Namespace>
  <Namespace>IanAutomation</Namespace>
  <Namespace>IanAutomation.Apps.Hotmail</Namespace>
  <Namespace>IanAutomation.FileHelpers</Namespace>
  <Namespace>IanAutomation.ImageFiles</Namespace>
  <Namespace>OpenQA.Selenium</Namespace>
  <Namespace>System.Configuration</Namespace>
  <Namespace>System.Drawing</Namespace>
  <Namespace>System.Windows.Forms</Namespace>
</Query>

void Main()
{
	//EmguCV_HelloWorld.Run();
	
	string formPath = @"F:\projects_csharp\OpenCV-practice\form.jpg";
	string scannedPath = @"F:\projects_csharp\OpenCV-practice\scanned-form.jpg";
	string title1 = "Scanned Form";
	string title2 = "Form";
	string title3 = "Matches";
	string title4 = "Warped";
	
	// Initialize the ORB detector
	ORB orbDetector = new ORB();
		
	Rgb Green = new Rgb(0, 255, 0);
	Rgb Blue = new Rgb(0, 0, 255);

	try
	{
		
		Image<Bgr, Byte> Model = new Image<Bgr, Byte>(formPath);
		Console.WriteLine($"Image size is ({Model.Width}, {Model.Height}, {Model.NumberOfChannels})");
		
	    Image<Bgr, Byte> Scene = new Image<Bgr, Byte>(scannedPath);
		Console.WriteLine($"Image size is ({Scene.Width}, {Scene.Height}, {Scene.NumberOfChannels})");
		
	    CvInvoke.NamedWindow(title1);
	    CvInvoke.NamedWindow(title2);
	    CvInvoke.NamedWindow(title3);
	    CvInvoke.NamedWindow(title4);
		
		// Setup
		VectorOfKeyPoint corners1;
		VectorOfKeyPoint corners2;
		var matches = new VectorOfVectorOfDMatch();
		Mat mask;
		Mat homography;
		Mat warpedImage = new Mat();
		
		// Draw the matches
		var matchImage = Draw(Model.Mat, Scene.Mat);
		
		// Warp the image
		FindMatch(Model.Mat, Scene.Mat, out corners1, out corners2, matches, out mask, out homography);
		CvInvoke.WarpPerspective(Scene, warpedImage, homography, Model.Size, Inter.Linear, Warp.InverseMap);
		
		CvInvoke.Imshow(title1, Model);
		CvInvoke.Imshow(title2, Scene);
		CvInvoke.Imshow(title3, matchImage);
		CvInvoke.Imshow(title4, warpedImage);
		CvInvoke.WaitKey(0);
	}
	finally
	{
		CvInvoke.DestroyWindow(title1);
		CvInvoke.DestroyWindow(title2);
		CvInvoke.DestroyWindow(title3);
		CvInvoke.DestroyWindow(title4);
	}
	
	Console.WriteLine("done");
}

void GetFeatures(Image<Bgr, Byte> img, ORB detector, out VectorOfKeyPoint corners, out Mat descriptors)
{
	Mat grayFrame = new Mat();
	// convert to grayscale
	CvInvoke.CvtColor(img, grayFrame, ColorConversion.Bgr2Gray);
	
	// detect the corners
	corners = new VectorOfKeyPoint();
	descriptors = new Mat();
	detector.DetectAndCompute(grayFrame, null, corners, descriptors, false);
}

void AddFeatures(Image<Bgr, Byte> img, ORB detector)
{
	Mat grayFrame = new Mat();
	// convert to grayscale
	CvInvoke.CvtColor(img, grayFrame, ColorConversion.Bgr2Gray);
	
	// detect the corners
	VectorOfKeyPoint corners = new VectorOfKeyPoint();
	Mat descriptors = new Mat();
	detector.DetectAndCompute(grayFrame, null, corners, descriptors, false);
	foreach (var corner in corners.ToArray())
		CvInvoke.Circle(img, Point.Round(corner.Point), 10, Convert(new Rgb(0, 255, 0)), 1);
}

public MCvScalar Convert(Rgb Color)
{
	return new MCvScalar(Color.Blue, Color.Green, Color.Red);
}

// https://stackoverflow.com/a/57007608/20933515
public static void FindMatch(Mat modelImage, Mat observedImage, out VectorOfKeyPoint modelKeyPoints, out VectorOfKeyPoint observedKeyPoints, VectorOfVectorOfDMatch matches, out Mat mask, out Mat homography)
{
    int k = 2;
    double uniquenessThreshold = 0.80;
    homography = null;
    modelKeyPoints = new VectorOfKeyPoint();
    observedKeyPoints = new VectorOfKeyPoint();
    using (UMat uModelImage = modelImage.GetUMat(AccessType.Read))
    using (UMat uObservedImage = observedImage.GetUMat(AccessType.Read))
    {
        var featureDetector = new ORB(9000);
        Mat modelDescriptors = new Mat();
        featureDetector.DetectAndCompute(uModelImage, null, modelKeyPoints, modelDescriptors, false);
        Mat observedDescriptors = new Mat();
        featureDetector.DetectAndCompute(uObservedImage, null, observedKeyPoints, observedDescriptors, false);
        using (var matcher = new BFMatcher(DistanceType.Hamming, false))
        {
            matcher.Add(modelDescriptors);

            matcher.KnnMatch(observedDescriptors, matches, k, null);
            mask = new Mat(matches.Size, 1, DepthType.Cv8U, 1);
            mask.SetTo(new MCvScalar(255));
            Features2DToolbox.VoteForUniqueness(matches, uniquenessThreshold, mask);

            int nonZeroCount = CvInvoke.CountNonZero(mask);
            if (nonZeroCount >= 4)
            {
                nonZeroCount = Features2DToolbox.VoteForSizeAndOrientation(modelKeyPoints, observedKeyPoints,
                    matches, mask, 1.5, 20);
                if (nonZeroCount >= 4)
                    homography = Features2DToolbox.GetHomographyMatrixFromMatchedFeatures(modelKeyPoints,
                        observedKeyPoints, matches, mask, 2);
            }
        }
    }
}						

// https://stackoverflow.com/a/57007608/20933515
public static Mat Draw(Mat modelImage, Mat observedImage)
{
    Mat homography;
    VectorOfKeyPoint modelKeyPoints;
    VectorOfKeyPoint observedKeyPoints;
    using (VectorOfVectorOfDMatch matches = new VectorOfVectorOfDMatch())
    {
        Mat mask;
        FindMatch(modelImage, observedImage, out modelKeyPoints, out observedKeyPoints, matches, out mask, out homography);
        Mat result = new Mat();
        Features2DToolbox.DrawMatches(modelImage, modelKeyPoints, observedImage, observedKeyPoints,
            matches, result, new MCvScalar(255, 0, 0), new MCvScalar(0, 0, 255), mask);

        if (homography != null)
        {
            var imgWarped = new Mat();
            CvInvoke.WarpPerspective(observedImage, imgWarped, homography, modelImage.Size, Inter.Linear, Warp.InverseMap);
            Rectangle rect = new Rectangle(Point.Empty, modelImage.Size);
            var pts = new PointF[]
            {
                  new PointF(rect.Left, rect.Bottom),
                  new PointF(rect.Right, rect.Bottom),
                  new PointF(rect.Right, rect.Top),
                  new PointF(rect.Left, rect.Top)
            };

            pts = CvInvoke.PerspectiveTransform(pts, homography);
            var points = new Point[pts.Length];
            for (int i = 0; i < points.Length; i++)
                points[i] = Point.Round(pts[i]);

            using (var vp = new VectorOfPoint(points))
            {
                CvInvoke.Polylines(result, vp, true, new MCvScalar(255, 0, 0, 255), 5);
            }
        }
        return result;
    }
}						
						
						
						
						
						
						
						
						
						
						
						
						